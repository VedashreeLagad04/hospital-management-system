!function(){"use strict";const t=[];for(let n=0;n<256;n++){let e=n;for(let t=0;t<8;t++)1&e?e=e>>>1^3988292384:e>>>=1;t[n]=e}class n{constructor(){this.crc=-1}append(n){let e=0|this.crc;for(let s=0,i=0|n.length;s<i;s++)e=e>>>8^t[255&(e^n[s])];this.crc=e}get(){return~this.crc}}const e="Invalid pasword",s=16,i="raw",a={name:"PBKDF2"},r={name:"HMAC"},c="SHA-1",h={name:"AES-CTR"},o=Object.assign({hash:r},a),p=Object.assign({iterations:1e3,hash:{name:c}},a),u=Object.assign({hash:c},r),d=Object.assign({length:s},h),l=["deriveBits"],g=["sign"],y=[8,12,16],w=[16,24,32],f=10,A=[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],U=crypto.subtle;class b{constructor(t,n,e){this.password=t,this.signed=n,this.strength=e-1,this.input=n&&new Uint8Array(0),this.pendingInput=new Uint8Array(0)}async append(t){const n=async(e=0)=>{if(e+s<=a.length-f){const t=a.subarray(e,e+s),r=await U.decrypt(Object.assign({counter:this.counter},d),this.keys.key,t);return D(this.counter),i.set(new Uint8Array(r),e),n(e+s)}return this.pendingInput=a.subarray(e),this.signed&&(this.input=I(this.input,t)),i};if(this.password){const n=t.subarray(0,y[this.strength]+2);await async function(t,n,s){await k(t,s,n.subarray(0,y[t.strength]),["decrypt"]);const i=n.subarray(y[t.strength]),a=t.keys.passwordVerification;if(a[0]!=i[0]||a[1]!=i[1])throw new Error(e)}(this,n,this.password),this.password=null,t=t.subarray(y[this.strength]+2)}let i=new Uint8Array(t.length-f-(t.length-f)%s),a=t;return this.pendingInput.length&&(a=I(this.pendingInput,t),i=C(i,a.length-f-(a.length-f)%s)),n()}async flush(){const t=this.pendingInput,n=this.keys,e=t.subarray(0,t.length-f),s=t.subarray(t.length-f);let i=new Uint8Array(0);if(e.length){const t=await U.decrypt(Object.assign({counter:this.counter},d),n.key,e);i=new Uint8Array(t)}let a=!0;if(this.signed){const t=await U.sign(r,n.authentication,this.input.subarray(0,this.input.length-f)),e=new Uint8Array(t);this.input=null;for(let t=0;t<f;t++)e[t]!=s[t]&&(a=!1)}return{valid:a,data:i}}}class m{constructor(t,n){this.password=t,this.strength=n-1,this.output=new Uint8Array(0),this.pendingInput=new Uint8Array(0)}async append(t){const n=async(a=0)=>{if(a+s<=t.length){const r=t.subarray(a,a+s),c=await U.encrypt(Object.assign({counter:this.counter},d),this.keys.key,r);return D(this.counter),i.set(new Uint8Array(c),a+e.length),n(a+s)}return this.pendingInput=t.subarray(a),this.output=I(this.output,i),i};let e=new Uint8Array(0);this.password&&(e=await async function(t,n){const e=crypto.getRandomValues(new Uint8Array(y[t.strength]));return await k(t,n,e,["encrypt"]),I(e,t.keys.passwordVerification)}(this,this.password),this.password=null);let i=new Uint8Array(e.length+t.length-t.length%s);return i.set(e,0),this.pendingInput.length&&(t=I(this.pendingInput,t),i=C(i,t.length-t.length%s)),n()}async flush(){let t=new Uint8Array(0);if(this.pendingInput.length){const n=await U.encrypt(Object.assign({counter:this.counter},d),this.keys.key,this.pendingInput);t=new Uint8Array(n),this.output=I(this.output,t)}const n=await U.sign(r,this.keys.authentication,this.output.subarray(y[this.strength]+2));this.output=null;const e=new Uint8Array(n).subarray(0,f);return{data:I(t,e),signature:e}}}async function k(t,n,e,s){t.counter=new Uint8Array(A);const a=(new TextEncoder).encode(n),r=await U.importKey(i,a,o,!1,l),c=await U.deriveBits(Object.assign({salt:e},p),r,8*(2*w[t.strength]+2)),d=new Uint8Array(c);t.keys={key:await U.importKey(i,d.subarray(0,w[t.strength]),h,!0,s),authentication:await U.importKey(i,d.subarray(w[t.strength],2*w[t.strength]),u,!1,g),passwordVerification:d.subarray(2*w[t.strength])}}function D(t){for(let n=0;n<16;n++){if(255!=t[n]){t[n]++;break}t[n]=0}}function I(t,n){let e=t;return t.length+n.length&&(e=new Uint8Array(t.length+n.length),e.set(t,0),e.set(n,t.length)),e}function C(t,n){if(n&&n>t.length){const e=t;(t=new Uint8Array(n)).set(e,0)}return t}const v="deflate",S="inflate",j="Invalid signature";class E{constructor(t){this.signature=t.inputSignature,this.encrypted=Boolean(t.inputPassword),this.signed=t.inputSigned,this.compressed=t.inputCompressed,this.inflate=t.inputCompressed&&new t.codecConstructor,this.crc32=t.inputSigned&&new n,this.decrypt=this.encrypted&&new b(t.inputPassword,t.inputSigned,t.inputEncryptionStrength)}async append(t){return this.encrypted&&(t=await this.decrypt.append(t)),this.compressed&&t.length&&(t=await this.inflate.append(t)),!this.encrypted&&this.signed&&this.crc32.append(t),t}async flush(){let t,n=new Uint8Array(0);if(this.encrypted){const t=await this.decrypt.flush();if(!t.valid)throw new Error(j);n=t.data}else if(this.signed){const n=new DataView(new Uint8Array(4).buffer);if(t=this.crc32.get(),n.setUint32(0,t),this.signature!=n.getUint32(0,!1))throw new Error(j)}return this.compressed&&(n=await this.inflate.append(n)||new Uint8Array(0),await this.inflate.flush()),{data:n,signature:t}}}class O{constructor(t){this.encrypted=t.outputEncrypted,this.signed=t.outputSigned,this.compressed=t.outputCompressed,this.deflate=t.outputCompressed&&new t.codecConstructor({level:t.level||5}),this.crc32=t.outputSigned&&new n,this.encrypt=this.encrypted&&new m(t.outputPassword,t.outputEncryptionStrength)}async append(t){let n=t;return this.compressed&&t.length&&(n=await this.deflate.append(t)),this.encrypted?n=await this.encrypt.append(n):this.signed&&this.crc32.append(t),n}async flush(){let t,n=new Uint8Array(0);if(this.compressed&&(n=await this.deflate.flush()||new Uint8Array(0)),this.encrypted){n=await this.encrypt.append(n);const e=await this.encrypt.flush();t=e.signature;const s=new Uint8Array(n.length+e.data.length);s.set(n,0),s.set(e.data,n.length),n=s}else this.signed&&(t=this.crc32.get());return{data:n,signature:t}}}const T={init(t){t.scripts&&t.scripts.length&&importScripts.apply(void 0,t.scripts);const n=t.options;self.initCodec&&self.initCodec(),n.codecType.startsWith(v)?n.codecConstructor=self.Deflate:n.codecType.startsWith(S)&&(n.codecConstructor=self.Inflate),M=function(t){return t.codecType.startsWith(v)?new O(t):t.codecType.startsWith(S)?new E(t):void 0}(n)},append:async t=>({data:await M.append(t.data)}),flush:()=>M.flush()};let M;addEventListener("message",(async t=>{const n=t.data,e=n.type,s=T[e];if(s)try{const t=await s(n)||{};if(t.type=e,t.data)try{postMessage(t,[t.data.buffer])}catch(n){postMessage(t)}else postMessage(t)}catch(t){postMessage({type:e,error:{message:t.message,stack:t.stack}})}}));const V="function";function B(t,n){return class{constructor(e){const s=t=>{if(this.pendingData){const n=this.pendingData;this.pendingData=new Uint8Array(n.length+t.length),this.pendingData.set(n,0),this.pendingData.set(t,n.length)}else this.pendingData=new Uint8Array(t)};if(this.codec=new t(Object.assign({},n,e)),typeof this.codec.onData==V)this.codec.onData=s;else{if(typeof this.codec.on!=V)throw new Error("Cannot register the callback function");this.codec.on("data",s)}}async append(t){return this.codec.push(t),e(this)}async flush(){return this.codec.push(new Uint8Array(0),!0),e(this)}};function e(t){if(t.pendingData){const n=t.pendingData;return t.pendingData=null,n}return new Uint8Array(0)}}self.initCodec=()=>{const{Deflate:t,Inflate:n}=((t,n={})=>({Deflate:B(t.Deflate,n.deflate),Inflate:B(t.Inflate,n.inflate)}))(pako,{deflate:{raw:!0},inflate:{raw:!0}});self.Deflate=t,self.Inflate=n}}();
